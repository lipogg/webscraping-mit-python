

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>9.3. Fortsetzung Selenium &#8212; Webscraping für Geisteswissenschaften</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=12da95d707ffb74b382d" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=12da95d707ffb74b382d" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=12da95d707ffb74b382d" />

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/09/subchapters/03_fortsetzung_selenium';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="9.2. Einstieg Selenium" href="02_einstieg_selenium.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../intro.html">
                    Webscraping mit Python für Geisteswissenschaften
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../01/01_intro.html">1. Einstieg</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../01/subchapters/01_was_ist_webscraping.html">1.1. Was ist Web Scraping?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01/subchapters/02_warum_webscraping_lernen.html">1.2. Coding vs. Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01/subchapters/03_semesterplan.html">1.3. Semesterplan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01/subchapters/04_lernziele.html">1.4. Lernziele</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../01/subchapters/05_organisation.html">1.5. Organisatorisches</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../02/02_intro.html">2. Python I</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../02/subchapters/01_jupyterlite.html">2.1. JupyterLite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/subchapters/01_style.html">2.2. Style Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/subchapters/01_hilfe.html">2.3. Hilfe!!</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/subchapters/02_grundbegriffe.html">2.4. Grundbegriffe</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/subchapters/03_datentypen.html">2.5. Einfache Datentypen, Strings und Operatoren</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../02/subchapters/04_variablen.html">2.6. Variablen</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../03/03_intro.html">3. Python II</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../03/subchapters/01_datentypen.html">3.1. Zusammengesetzte Datentypen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../03/subchapters/02_kontrollstrukturen.html">3.2. Kontrollstrukturen</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../04/04_intro.html">4. Python III</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../04/subchapters/01_funktionen.html">4.1. Funktionen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../04/subchapters/02_pakete.html">4.2. Pakete</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../05/05_intro.html">5. Installation und Setup</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../05/subchapters/01_vorbereitung.html">5.1. Vorbereitung</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../05/subchapters/02_installation_setup.html">5.2. Installation und Setup</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../06/06_intro.html">6. Einstieg Webscraping</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../06/subchapters/01_rechtliches.html">6.1. Der rechtliche Rahmen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../06/subchapters/02_html.html">6.2. HTML</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../06/subchapters/03_css.html">6.3. CSS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../06/subchapters/04_http.html">6.4. Client, Server, HTTP</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../07/07_intro.html">7. Statische Webseiten</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../07/subchapters/01_einstieg_beautifulsoup.html">7.1. Einstieg BeautifulSoup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../07/subchapters/02_fortsetzung_beautifulsoup.html">7.2. Fortsetzung BeautifulSoup</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../08/08_intro.html">8. APIs (Exkurs)</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../08/subchapters/01_apis.html">8.1. APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../08/subchapters/02_dracor_api.html">8.2. Beispiel DraCor-API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../08/subchapters/03_loc_api.html">8.3. Beispiel LOC-API</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../09_intro.html">9. Dynamische Webseiten</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_statisch_vs_dynamisch.html">9.1. Statisch vs. Dynamisch?</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_einstieg_selenium.html">9.2. Einstieg Selenium</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">9.3. Fortsetzung Selenium</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/lipogg/webscraping-mit-python" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/chapters/09/subchapters/03_fortsetzung_selenium.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Fortsetzung Selenium</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#popup-fenster-schlieszen">9.3.1. Popup-Fenster schließen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#methode-1-button-klicken">9.3.1.1. Methode 1: Button klicken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#methode-2-mauszeiger-bewegen-und-neben-das-fenster-klicken">9.3.1.2. Methode 2: Mauszeiger bewegen und neben das Fenster klicken</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scrollvorgang-simulieren-und-seiteninhalte-laden">9.3.2. Scrollvorgang simulieren und Seiteninhalte laden</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quellen">9.3.3. Quellen</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="fortsetzung-selenium">
<h1><span class="section-number">9.3. </span>Fortsetzung Selenium<a class="headerlink" href="#fortsetzung-selenium" title="Permalink to this heading">#</a></h1>
<p>In der letzten Woche haben wir uns angesehen, wie wir Zitate von der Seite <a class="reference external" href="https://quotes.toscrape.com/js/">https://quotes.toscrape.com/js/</a> mithilfe von Selenium scrapen können. Heute werden wir uns ein etwas fortgeschritteneres Beispiel ansehen, bei dem die Interaktion mit verschiedenen Seitenelementen notwendig wird: Wir werden Ortsangaben zu Unterkünften von <a class="reference external" href="https://www.airbnb.com/">https://www.airbnb.com/</a> scrapen, zuerst die Unterkünfte von der Startseite (heute), und danach Unterkünfte nur in Berlin (nächste Woche).</p>
<p>Zunächst rufen wir die Website im regulären Browser auf. Welche Interaktionen sind notwendig, um an die gesuchten Daten zu gelangen? Wenn wir die Startseite aufrufen, erscheint zunächst ein Popup-Fenster. Das Fenster kann geschlossen werden, indem auf den x-Button oder irgendwo neben das Fenster geklickt wird. Dann scrollen wir auf der Seite herunter, um die restlichen Unterkünfte zu sehen. Am Seitenende befindet sich ein “Show more”-Button. Wenn der Button geklickt wird, wird eine weitere Seite mit Unterkünften geöffnet. Die Inhalte werden beim Herunterscrollen nachgeladen, bis irgendwann das Seitenende erreicht ist. All diese Schritte müssen wir simulieren, wenn wir die Ortsangaben von den Unterkünften extrahieren wollen.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Achtung: Beim Scrapen komplexerer Webseiten wird der Code nicht beim ersten Mal fehlerfrei ausgeführt werden. Wird die Ausführung abbricht und eine Fehlermeldung angezeigt, dann wird die aktuelle Sitzung aber nicht mehr geschlossen. Das heißt: Immer, wenn der Code abbricht, müsst ihr die Sitzung manuell mit <code class="docutils literal notranslate"><span class="pre">driver.quit()</span></code> schließen, und vor dem nächsten Versuch wieder eine neue Sitzung starten mit <code class="docutils literal notranslate"><span class="pre">webdriver.Chrome()</span></code>!</p>
</div>
<p>Zu Beginn laden wir wieder alle notwendigen Pakete, starten eine Sitzung und stellen eine HTTP Get-Anfrage:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># from selenium import webdriver</span>
<span class="c1"># from selenium.webdriver.common.by import By</span>
<span class="c1"># import time</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># driver = webdriver.Chrome()</span>
<span class="c1"># driver.get(&quot;https://www.airbnb.com/&quot;)</span>
<span class="c1"># time.sleep(5) # 5 Sekunden warten, damit Inhalte laden können</span>
</pre></div>
</div>
</div>
</div>
<section id="popup-fenster-schlieszen">
<h2><span class="section-number">9.3.1. </span>Popup-Fenster schließen<a class="headerlink" href="#popup-fenster-schlieszen" title="Permalink to this heading">#</a></h2>
<p>Beim manuellen Aufruf der Seite haben wir gesehen, dass das Popup-Fenster mit zwei verschiedenen Methoden geschlossen werden kann: Entweder, es wird auf den x-Button geklickt, oder irgendwo neben das Popup-Fenster. Beides können wir mithilfe von Selenium simulieren.</p>
<section id="methode-1-button-klicken">
<h3><span class="section-number">9.3.1.1. </span>Methode 1: Button klicken<a class="headerlink" href="#methode-1-button-klicken" title="Permalink to this heading">#</a></h3>
<p>Zum Simulieren des Mausklicks auf einen Button gibt es wiederum zwei Möglichkeiten. In jedem Fall muss zunächst das HTML-Element, das zur Darstellung des Buttons verwendet wird, gesucht werden.</p>
<p>Um das Element zu suchen, verwenden wir als erstes wieder die Browser-Entwicklertools: Mit Rechtsklick auf den Button und Auswahl von “Inspect” wird der Quelltext der Seite automatisch an der richtigen Stelle in den Entwicklertools geöffnet. Häufig wird nicht exakt das gesuchte Element markiert, sondern ein Kind- oder Elternelement. Das richtige Element heißt &lt;button&gt;:</p>
<figure class="align-default" id="id144">
<a class="bg-transparent reference internal image-reference" href="../../../_images/beispiel_airbnb_1.png"><img alt="Airbnb Beispiel 1" class="bg-transparent" src="../../../_images/beispiel_airbnb_1.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.9 </span><span class="caption-text">Button-Element mithilfe der Entwicklertools suchen.</span><a class="headerlink" href="#id144" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Welches Attribut identifiziert das button-Element eindeutig? Das button-Element hat ein “class”-Attribut, das allerdings eine sehr lange Zeichenkette als Wert hat. Das kann vorkommen, wenn mehrere CSS-Klassen zur Identifizierung eines HTML-Elements verwendet werden. Verschiedene Klassen werden dabei durch ein Leerzeichen getrennt. Das Leerzeichen verursacht aber bei der Suche mit By.CLASS_NAME ein Problem und führt dazu, dass der Code eine Fehlermeldung produziert. Bei einer so langen Zeichenkette wäre das manuelle Ersetzen der Leerzeichen durch Punkte hier jedoch keine gute Lösung.
Stattdessen könnten wir überprüfen, ob das gesuchte Element schon durch die erste CSS-Klasse oder nur einige wenige Klassen eindeutig definiert wird. Das können wir überprüfen, in dem wir in den Entwicklertools mit der Tastenkombination <code class="docutils literal notranslate"><span class="pre">STRG</span> <span class="pre">+</span> <span class="pre">F</span></code> nach der ersten CSS-Klasse suchen. Es zeigt sich: Der Close-Button ist nicht der Einzige, der diese CSS-Klasse hat; sondern es gibt sehr viele Elemente mit dieser Klasse:</p>
<figure class="align-default" id="id145">
<a class="bg-transparent reference internal image-reference" href="../../../_images/beispiel_airbnb_2.png"><img alt="Airbnb Beispiel 2" class="bg-transparent" src="../../../_images/beispiel_airbnb_2.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.10 </span><span class="caption-text">Suche nach CSS-Klasse mit STRG + F.</span><a class="headerlink" href="#id145" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Wir können also das Button-Element nicht eindeutig über die gewählte CSS-Klasse addressieren. Wir könnten jetzt natürlich verschiedene Kombinationen von CSS-Klassen ausprobieren, aber das Button-Element hat noch ein weiteres Attribut, über das das Button-Element etwas einfacher addressiert werden kann: Das Attribut  aria-label mit dem Wert “Close”. Wir verwenden stattdessen dieses Attribut für die Suche und definieren dazu einen sogenannten XPATH-Ausdruck. XPATH ist eine Pfadbeschreibungssprache, mit der HTML-Elemente anhand ihrer Hierarchie, Attributen, Textinhalten und weiteren Eigenschaften lokalisiert werden können. So können wir zum Beispiel den Button mit dem XPATH-Ausdruck <code class="docutils literal notranslate"><span class="pre">//button[&#64;aria-label='Close']</span></code> auswählen. Dieser Ausdruck sucht nach einem Element mit den Namen button (<code class="docutils literal notranslate"><span class="pre">button</span></code>), irgendwo im HTML-Baum (<code class="docutils literal notranslate"><span class="pre">//</span></code>), das ein Attribut  <code class="docutils literal notranslate"><span class="pre">aria-label</span></code> mit dem Wert <code class="docutils literal notranslate"><span class="pre">'Close'</span></code> hat (<code class="docutils literal notranslate"><span class="pre">[&#64;aria-label='Close']</span></code>). Einen Überblick über verschiedene Möglichkeiten, in Selenium nach Elementen zu suchen, findet ihr <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/elements/locators/#traditional-locators">hier</a>.</p>
<p>Anschließend kann der Mausklick mit der <strong>Selenium-Methode <code class="docutils literal notranslate"><span class="pre">.click()</span></code></strong> simuliert werden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># close_button = driver.find_element(By.XPATH, &quot;//button[@aria-label=&#39;Close&#39;]&quot;)</span>
<span class="c1"># close_button.click()</span>
</pre></div>
</div>
</div>
</div>
<p>Dieser Code produziert jedoch eine Fehlermeldung “ElementNotInteractable”. Woran liegt das? Wenn wir wieder mit STRG + F das Suchfenster in den Entwicklertools öffnen und nach dem XPATH-Pfad suchen, erhalten wir zwei Ergebnisse, und nicht eins wie erwartet. Die Methode <code class="docutils literal notranslate"><span class="pre">.find_element()</span></code> gibt aber natürlich nur das erste der beiden Suchergebnisse zurück. Das erste der beiden gefundenen Elemente ist aber scheinbar nicht anklickbar bzw. eben “nicht interagierbar”. Wir können stattdessen versuchen, das andere gefundene Element anzuklicken. Dazu müssen wir aber unsere Suche anders formulieren:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># close_button_elems = driver.find_elements(By.XPATH, &quot;//button[@aria-label=&#39;Close&#39;]&quot;)</span>
<span class="c1"># close_button_elems[1].click() # Zweites Element aus der Liste mit den gefundenen Elementen anklciken</span>
</pre></div>
</div>
</div>
</div>
<p>Mit dem geänderten Code lässt sich der Mausklick erfolgreich simulieren.</p>
<p>Falls die erste Methode jedoch nicht zum Ziel führt, gibt es eine alternative Möglichkeit, einen Button anzuklicken, und zwar, indem das JavaScript Code Snippet ausgeführt wird, das dafür zuständig ist, den Mausklick im Browser auszulösen. Dazu wird die <strong>Selenium-Methode <code class="docutils literal notranslate"><span class="pre">.execute_script()</span></code></strong> im Zusammenhang mit der <strong>Javascript-Methode <code class="docutils literal notranslate"><span class="pre">.click()</span></code></strong> verwendet. Die JavaScript-Methode heißt ebenfalls <code class="docutils literal notranslate"><span class="pre">.click()</span></code> und ist genau wie die Selenium-Methode <code class="docutils literal notranslate"><span class="pre">.click()</span></code>  für HTML-Elemente definiert, aber eben für JavaScript und nicht Python. Im Codebeispiel unten steht  <code class="docutils literal notranslate"><span class="pre">arguments[0]</span></code> für das HTML-Element, das angeklickt werden soll. Das Element muss deswegen wieder zuerst gesucht werden und einer Variable zugewiesen werden. Diese Variable (hier <code class="docutils literal notranslate"><span class="pre">close_button</span></code>) wird der <code class="docutils literal notranslate"><span class="pre">.execute_script()</span></code>-Methode als Argument übergeben. <code class="docutils literal notranslate"><span class="pre">arguments[0]</span></code> verweist dann auf das Argument.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># close_button = driver.find_element(By.XPATH, &quot;//button[@aria-label=&#39;Close&#39;]&quot;)</span>
<span class="c1"># driver.execute_script(&quot;arguments[0].click();&quot;, close_button)</span>
<span class="c1"># time.sleep(5)</span>
</pre></div>
</div>
</div>
</div>
<p>Unter den folgenden Links findet ihr Hintergrundinformationen und Anwendungsbeispiele zur <code class="docutils literal notranslate"><span class="pre">.execute_sript()</span></code> Methode:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.selenium.dev/documentation/webdriver/interactions/windows/#execute-script">https://www.selenium.dev/documentation/webdriver/interactions/windows/#execute-script</a></p></li>
<li><p><a class="reference external" href="https://docs.pylenium.io/driver-commands/browser/execute_script">https://docs.pylenium.io/driver-commands/browser/execute_script</a></p></li>
</ul>
</section>
<section id="methode-2-mauszeiger-bewegen-und-neben-das-fenster-klicken">
<h3><span class="section-number">9.3.1.2. </span>Methode 2: Mauszeiger bewegen und neben das Fenster klicken<a class="headerlink" href="#methode-2-mauszeiger-bewegen-und-neben-das-fenster-klicken" title="Permalink to this heading">#</a></h3>
<p>Die zweite Möglichkeit, das Fenster zu schließen, besteht darin, irgendwo neben das Fenster zu klicken. Auch das kann mithilfe von Selenium simuliert werden. Dazu muss zunächst ein Element gefunden werden, das eindeutig identifiziert werden kann. In unserem Beispiel ist das z.B. das div-Element mit der Klasse “_17t88vi”, das das Popup-Fenster repräsentiert. Wenn wir nach der Klasse “_17t88vi” suchen, wird nur ein Ergebnis gefunden. Wir können also zunächst den Mauszeiger in die Mitte dieses Elements bewegen, und von dort aus den Mauszeiger um eine festgelegte Pixelanzahl nach oben (y) und nach rechts (x) bewegen, also genau wie in einem Kartesischen Koordinatensystem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># mouse_tracker = driver.find_element(By.CLASS_NAME, &quot;_17t88vi&quot;)</span>

<span class="c1"># Koordinaten</span>
<span class="c1"># x_coordinate = 450 (etwa 12 cm in Pixeln)</span>
<span class="c1"># y_coordinate = 450</span>

<span class="c1"># ActionChains(driver).move_by_offset(x_coordinate, y_coordinate).click().perform()</span>
<span class="c1"># Mausposition neu ausrichten</span>
<span class="c1"># ActionChains(driver).move_by_offset(-x_coordinate, -y_coordinate).perform()</span>
<span class="c1"># time.sleep(5)</span>
</pre></div>
</div>
</div>
</div>
<p>Hintergrundinformationen und Anwendungsbeispiele zur Methode <code class="docutils literal notranslate"><span class="pre">.move_by_offset()</span></code> findet ihr unter <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/actions_api/mouse/#offset-from-element">https://www.selenium.dev/documentation/webdriver/actions_api/mouse/#offset-from-element</a>. Alternativ kann die Maus auch von der linken oberen Ecke des aktuell angezeigten Bereichs um eine bestimmte Pixelanzahl bewegt werden (siehe dazu die <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/actions_api/mouse/#offset-from-viewport">Selenium-Dokumentationsseiten</a>).</p>
<p>Das Vorgehen mit <code class="docutils literal notranslate"><span class="pre">.move_by_offset()</span></code> ist jedoch ziemlich ungenau, weil sich die Größe des Browserfensters und entsprechend der Seiteninhalte von Gerät zu Gerät unterscheiden kann. Diese Methode sollte deswegen als eine Art “last resort” behandelt werden.</p>
</section>
</section>
<section id="scrollvorgang-simulieren-und-seiteninhalte-laden">
<h2><span class="section-number">9.3.2. </span>Scrollvorgang simulieren und Seiteninhalte laden<a class="headerlink" href="#scrollvorgang-simulieren-und-seiteninhalte-laden" title="Permalink to this heading">#</a></h2>
<p>Nachdem das Popup-Fenster geschlossen ist, muss zum Seitenende gescrollt werden, wo sich der “Show more” Button befindet. Wir sollten zunächst überprüfen, ob der Button bereits beim Aufruf der Seite geladen wird. Dazu können wir manuell zum Seitenende scrollen, mit Rechtsklick und Inspect den “Show more”-Button in den Entwicklertools anzeigen lassen, und die CSS-Klassen in die Zwischenablage kopieren, also den gesamten String “l1ovpqvx…dir-ltr”.</p>
<figure class="align-default" id="id146">
<a class="bg-transparent reference internal image-reference" href="../../../_images/beispiel_airbnb_3.png"><img alt="Airbnb Beispiel 3" class="bg-transparent" src="../../../_images/beispiel_airbnb_3.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.11 </span><span class="caption-text">Button-Element in den Entwicklertools.</span><a class="headerlink" href="#id146" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Anschließend laden wir die Seite neu, schließen das Popup-Fenster, und suchen in den Entwicklertools wird mit STRG-F nach dem String. Die Suche sollte keine Ergebnisse liefern. Wenn wir jedoch zum Seitenende scrollen und erneut nach dem String suchen, wird das Element nun gefunden und die Suche liefert ein Ergebnis. Das bedeutet: Die Seiteninhalte werden auf der airbnb.com-Startseite erst dann geladen, wenn sie sich im aktuellen Anzeigebereich befinden. Diesen Umstand können wir auch überprüfen, indem wir mit Selenium mit <code class="docutils literal notranslate"><span class="pre">.find_element()</span></code> nach dem Button mit suchen: Die Suche produziert die Fehlermeldung “NoSuchElementException”. Um die restlichen Unterkünfte auf der Startseite sowie den “Show more” Button zu laden, müssen wir also zunächt bis zum Seitenende scrollen.</p>
<p>In Selenium gibt es verschiedene Möglichkeiten, einen Scrollvorgang zu simulieren. Wenn bereits alle Elemente geladen wurden und nur ein Element in den aktuellen Anzeigebereich gescrollt werden soll, kann die Methode <code class="docutils literal notranslate"><span class="pre">.scroll_to_element()</span></code> verwendet werden (siehe <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/actions_api/wheel/#scroll-to-element">Selenium-Dokumentationsseite</a>). Wie wir gesehen haben, wird der “Show more” Button zusammen mit den restlichen Inhalten allerdings erst durch das Scrollen mithilfe von Javascript in das HTML-Gerüst der Webseite eingefügt. Das gesuchte button-Element wird also beim Aufruf der Seite noch nicht gefunden und die Methode <code class="docutils literal notranslate"><span class="pre">.find_element()</span></code> produziert entsprechend eine Fehlermeldung “NoSuchElementException”. Wir könnten uns aber diesen Umstand zunutze machen und beispielsweise so lange scrollen, bis das gesuchte Element gefunden wird. Bevor wir diese Strategie umsetzen können, müssen wir allerdings noch ein Thema kennenlernen, das wir erst nächste Woche besprechen.</p>
<p>Etwas allgemeiner und einstiegsfreundlicher ist der folgende <strong>Ansatz, bei dem so lange um eine bestimmte Pixelanzahl nach unten gescrollt wird, bis der bereits durchscrollte Bereich zusammen mit dem aktuell angezeigten Bereich größer oder gleich der Gesamthöhe der Webseite in Pixeln ist.</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Variablen für das Scrollen festlegen</span>
<span class="c1"># scroll_pause_time = 2  # Pausieren zwischen den Scroll-Vorgängen</span>
<span class="c1"># scroll_step = 300  # Schrittgröße für jeden Scroll-Vorgang (in Pixeln)</span>

<span class="c1"># Erste Seite bis zum Ende scrollen</span>
<span class="c1"># while True:</span>
<span class="c1">#    # Um eine feste Pixelanzahl scrollen</span>
<span class="c1">#    driver.execute_script(f&quot;window.scrollBy(0, {scroll_step});&quot;)</span>
<span class="c1">#    time.sleep(scroll_pause_time)</span>
<span class="c1">#    # Scroll-Höhe nach dem Scrollen aktualisieren</span>
<span class="c1">#    scroll_height = driver.execute_script(&quot;return document.body.scrollHeight;&quot;)</span>
<span class="c1">#    # Abbruchkriterium: überprüfen, ob das Ende der Seite erreicht ist</span>
<span class="c1">#    window_inner_height = driver.execute_script(&quot;return window.innerHeight;&quot;)</span>
<span class="c1">#    if driver.execute_script(&quot;return window.scrollY;&quot;) + window_inner_height &gt;= scroll_height:</span>
<span class="c1">#        break</span>
</pre></div>
</div>
</div>
</div>
<p>Zum Verständnis des Codes ist an dieser Stelle ein bisschen JavaScript-Kenntnis (bzw. Recherche in den JavaScript-Dokumentationsseiten) erforderlich:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.scrollBy()</span></code> ist eine JavaScript-Methode, die laut <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollBy">Dokumentationsseite</a> das im Browserfenster geöffnete HTML-Dokument um die angegebene Pixelanzahl scrollt. Das erste Argument gibt dabei die Pixel an, um die in horizontaler Richtung gescrollt werden soll. Das zweite Argument gibt die Pixel für das vertikale Scrollen an.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.scrollY</span></code> ist eine Eigenschaft des JavaScript-Objekts window. Das window-Objekt stellt das Browserfenster dar. .scrollY gibt laut <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY">Dokumentationsseite</a> die Anzahl an Pixeln an, um die das HTML-Dokument bereits in vertikaler Richtung durchscrollt wurde, also die aktuelle Scroll-Position in vertikaler Richtung. In einem Kartesischen Koordinatensystem wäre die vertikale Richtung durch die Y-Achse repräsentiert (daher der Name scrollY).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.scrollHeight</span></code> ist eine Eigenschaft des JavaScript-Objekts document.body, das laut <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight">Dokumentationsseite</a> die Höhe eines HTML-Elements in Pixeln angibt, und zwar sowohl für den sichtbaren als auch für den unsichtbaren Bereich, also die Gesamthöhe der scrollbaren Inhalte. Mit “unsichtbarer Bereich” ist der Bereich gemeint, der aufgrund des Scrollens außerhalb des aktuell sichtbaren Bereichs liegt. Mit document.body wird das HTML-Element angegeben, dessen Höhe bestimmt werden soll: In diesem Fall wählen wir das body-Element, weil es den gesamten darstellbaren Webseiteninhalt umfasst.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.innerHeight</span></code> ist eine Eigenschaft des JavaScript-Objekts window. Es gibt laut <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerHeight">Dokumentationsseite</a> die innere Höhe des Browserfensters in Pixeln an, also den Bereich, in dem tatsächlich die Webseite angezeigt wird, ohne die URL-Zeile, die Tabs, usw.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">return</span></code> ist das JavaScript-Pendant zur return-Anweisung in Python, die in Funktionsaufrufen verwendet wird, um einen Wert zurückzugeben. Wie genau diese Werte extrahiert werden, müssen wir nicht unbedingt wissen, um den Code zu verwenden. Aber wenn sich jemand nähergehend damit beschäftigen möchte, empfehle ich <a class="reference external" href="https://www.webtechnologien.com/advanced-tutorials/javascript-bom/">diese Seite</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Aber Achtung: <code class="docutils literal notranslate"><span class="pre">.innerHeight</span></code> ist die Höhe inklusive der Scrollleiste, die Höhe ohne die Scrolleiste wird mit <code class="docutils literal notranslate"><span class="pre">.clientHeight</span></code> angegeben. Für unser Beispiel ist auch der Wert für <code class="docutils literal notranslate"><span class="pre">.innerHeight</span></code> geeignet, aber je nach Anwendungsfall kann es ratsam sein, beim Scrollen etwas präziser vorzugehen und die Eigenschaft <code class="docutils literal notranslate"><span class="pre">.clientHeight</span></code> zu verwenden. Mehr dazu <a class="reference external" href="https://javascript.info/size-and-scroll-window">hier</a>.</p>
</div>
<p>Den Zusammenhang zwischen den verschiedenen Objekteigenschaften und ihre Bedeutung für Abbruchbedingung der while-Schleife lässt sich vielleicht ungefähr so veranschaulichen:</p>
<figure class="align-default" id="id147">
<a class="bg-transparent reference internal image-reference" href="../../../_images/javascript_attributes.png"><img alt="JavaScript Attribute" class="bg-transparent" src="../../../_images/javascript_attributes.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.12 </span><span class="caption-text">Veranschaulichung der JavaScript-Objekteigenschaften zur Formulierung der Abbruchbedingung.</span><a class="headerlink" href="#id147" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Wenn das Seitenende erreicht ist und die while-Schleife terminiert, kann der Mausklick auf den “Show more”-Button simuliert werden. Anschließend sollte wieder ein paar Sekunden gewartet werden, damit die neuen Inhalte laden können.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Button &quot;Show More&quot; klicken</span>
<span class="c1"># more_button = driver.find_element(By.XPATH, &quot;//button[contains(text(), &#39;Show more&#39;)]&quot;)</span>
<span class="c1"># driver.execute_script(&quot;arguments[0].click();&quot;, more_button)</span>
<span class="c1"># time.sleep(5)</span>
</pre></div>
</div>
</div>
</div>
<p>Anschließend muss wieder bis zum Seitenende gescrollt werden, damit alle Unterkünfte laden. “Laden” bedeutet hier zur Erinnerung, dass die neuen Inhalte in das HTML-Gerüst eingefügt werden und dadurch addressierbar werden. Der manuelle Scrollvorgang hat gezeigt, dass die Inhalte dynamisch geladen werden, sobald sie durch Scrollen in den sichtbaren Bereich gelangen. Aber anders als bei einem “echten” Infinite Scrolling endet die Seite nach einigen Scrollvorgängen. Wir könnten also beim Scrollen genauso vorgehen, wie beim Scrollen zum “Show more”-Button. Allerdings war dieser Scrollvorgang recht langsam, weil in jedem Schleifendurchlauf nur um 300 Pixel gescrollt wurde. Wir könnten also, um den Vorgang etwas zu beschleunigen, zum Beispiel die Pixelanzahl vergrößern. Hierbei sollte allerdings Folgendes bedacht werden: Je nachdem, wie groß das Browserfenster auf unterschiedlichen Geräten ist, haben auch die  Kacheln mit den Unterkünften eine unterschiedliche Größe und es gibt unterschiedlich viele Kacheln in einer Zeile. Es werden also je nach Größe des Browserfensters verschieden viele Kacheln geladen, wenn um 300, 500 oder 800 Pixel gescrollt wird. Wenn zu schnell gescrollt wird, dann können Inhalte nicht rechtzeitig geladen werden, und wenn das passiert, werden sie folglich von unserem Webscraper nicht gefunden.</p>
<p>Zum Scrollen  verwenden wir deswegen diesmal einen etwas zeiteffizienteren alternativen <strong>Ansatz, bei dem in jedem Schleifendurchlauf nicht um eine feste Pixelanzahl gescrollt wird, sondern um die innere Höhe des Browserfensters.</strong> Dieser Ansatz lässt sich vielleicht wie folgt veranschaulichen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Variablen für das Scrollen festlegen</span>
<span class="c1"># scroll_pause_time = 2 # Zwei Sekunde pausieren</span>
<span class="c1"># window_inner_height = driver.execute_script(&quot;return window.innerHeight;&quot;)</span>
<span class="c1"># i = 1</span>

<span class="c1"># Nächste Seite bis zum Ende scrollen:</span>
<span class="c1"># while True:</span>
<span class="c1">#     # Um die innere Höhe eines Browserffensters scrollen</span>
<span class="c1">#     driver.execute_script(f&quot;window.scrollTo(0, {window_inner_height}*{i});&quot;)</span>
<span class="c1">#     # Kurze Zeit warten, damit die Seite nach jedem Scroll-Vorgang laden kann</span>
<span class="c1">#     time.sleep(scroll_pause_time)</span>
<span class="c1">#     # Scroll-Höhe nach dem Scrollen aktualisieren, da sich die Scroll-Höhe nach dem Scrollen der Seite ändern kann</span>
<span class="c1">#     scroll_height = driver.execute_script(&quot;return document.body.scrollHeight;&quot;)</span>
<span class="c1">#     # Aktuelle Scroll-Position abrufen</span>
<span class="c1">#     scroll_position = driver.execute_script(&quot;return window.scrollY;&quot;)</span>
<span class="c1">#     # Schleife beenden, wenn die Höhe, zu der wir scrollen müssen, größer ist als die gesamte Scroll-Höhe</span>
<span class="c1">#     if scroll_position + window_inner_height &gt;= scroll_height:</span>
<span class="c1">#         break</span>
<span class="c1">#     i += 1</span>
</pre></div>
</div>
</div>
</div>
<p>Wenn die Schleife terminiert, ist der gesamte Seiteninhalt durchscrollt und gerendert. Anschließend können wieder die Ortsangaben extrahiert werden: find_elements() findet jetzt nicht nur die ersten 20 Suchergebnisse, sondern alle Ergebnisse. Hierzu können wir wieder entweder das class-Attribut verwenden und die CSS-Klassen abkürzen, oder wir formulieren einen XPATH-Ausdruck zur Suche nach einem anderen Attribut, beispielsweise das Attribut <code class="docutils literal notranslate"><span class="pre">data-testid</span></code>:</p>
<figure class="align-default" id="id148">
<a class="bg-transparent reference internal image-reference" href="../../../_images/beispiel_airbnb_4.png"><img alt="Airbnb Beispiel 4" class="bg-transparent" src="../../../_images/beispiel_airbnb_4.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 9.13 </span><span class="caption-text">Unterkunft in den Entwicklertools untersuchen.</span><a class="headerlink" href="#id148" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># # Daten extrahieren</span>
<span class="c1"># unterkuenfte = driver.find_elements(By.XPATH, &quot;//div[@data-testid=&#39;listing-card-title&#39;]&quot;) # Alternativ By.CLASS_NAME, &quot;t1jojoys&quot;</span>
<span class="c1"># unterkuenfte_orte = [unterkunft.text for unterkunft in unterkuenfte]</span>
<span class="c1"># unterkuenfte_orte</span>
</pre></div>
</div>
</div>
</div>
<p>Zuletzt schließen wir das aktuelle Browserfenster und die Session, also die Sitzung, welche durch den Aufruf des Chrome Webdrivers gestartet wird:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># driver.quit()</span>
</pre></div>
</div>
</div>
</div>
<p>Zum Abschluss möchte ich noch auf <a class="reference external" href="https://davidshivaji.medium.com/how-to-scroll-using-selenium-in-python-ad1eba1e9bca">diesen vierten Ansatz zum Scrollen mithilfe von Selenium von David Shivaji</a> verweisen. Überlegt selbst: Welche Vor-/Nachteile hat dieser Ansatz? Welche Parameter werden dabei verwendet?</p>
</section>
<section id="quellen">
<h2><span class="section-number">9.3.3. </span>Quellen<a class="headerlink" href="#quellen" title="Permalink to this heading">#</a></h2>
<div class="docutils container" id="id1">
<ol class="arabic simple" start="1">
<li id="id143"><p>David Shivaji. How to Scroll using Selenium in Python. 2021. URL: <a class="reference external" href="https://davidshivaji.medium.com/how-to-scroll-using-selenium-in-python-ad1eba1e9bca">https://davidshivaji.medium.com/how-to-scroll-using-selenium-in-python-ad1eba1e9bca</a>.</p></li>
<li id="id142"><p>Kuan Wei. Using Python and Selenium to Scrape Infinite Scroll Web Pages. 2020. URL: <a class="reference external" href="https://medium.com/analytics-vidhya/using-python-and-selenium-to-scrape-infinite-scroll-web-pages-825d12c24ec7">https://medium.com/analytics-vidhya/using-python-and-selenium-to-scrape-infinite-scroll-web-pages-825d12c24ec7</a>.</p></li>
<li id="id139"><p>Selenium 4 Documentation. Interacting with Web Elements. 2023. URL: <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/elements/interactions/">https://www.selenium.dev/documentation/webdriver/elements/interactions/</a>.</p></li>
<li id="id140"><p>Selenium 4 Documentation. Keyboard Actions. 2023. URL: <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/actions_api/keyboard/">https://www.selenium.dev/documentation/webdriver/actions_api/keyboard/</a>.</p></li>
</ol>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chapters/09/subchapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="02_einstieg_selenium.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">9.2. </span>Einstieg Selenium</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#popup-fenster-schlieszen">9.3.1. Popup-Fenster schließen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#methode-1-button-klicken">9.3.1.1. Methode 1: Button klicken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#methode-2-mauszeiger-bewegen-und-neben-das-fenster-klicken">9.3.1.2. Methode 2: Mauszeiger bewegen und neben das Fenster klicken</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scrollvorgang-simulieren-und-seiteninhalte-laden">9.3.2. Scrollvorgang simulieren und Seiteninhalte laden</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quellen">9.3.3. Quellen</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            <div class="bd-footer-content__inner">
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Lisa Poggel
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div></div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=12da95d707ffb74b382d"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=12da95d707ffb74b382d"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>